<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_121) on Mon Dec 12 16:43:53 PST 2016 -->
<title>java.util.stream (Java Platform SE 8 )</title>
<meta name="date" content="2016-12-12">
<meta name="keywords" content="java.util.stream package">
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="java.util.stream (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><strong>Java&trade;&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../java/util/spi/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../java/util/zip/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?java/util/stream/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;java.util.stream</h1>
<div class="docSummary">
<div class="block">Classes to support functional-style operations on streams of elements, such
 as map-reduce transformations on collections.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,S extends <a href="../../../java/util/stream/BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,S&gt;&gt;</td>
<td class="colLast">
<div class="block">Base interface for streams, which are sequences of elements supporting
 sequential and parallel aggregate operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,R&gt;</td>
<td class="colLast">
<div class="block">A <a href="package-summary.html#Reduction">mutable reduction operation</a> that
 accumulates input elements into a mutable result container, optionally transforming
 the accumulated result into a final representation after all input elements
 have been processed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></td>
<td class="colLast">
<div class="block">A sequence of primitive double-valued elements supporting sequential and parallel
 aggregate operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/DoubleStream.Builder.html" title="interface in java.util.stream">DoubleStream.Builder</a></td>
<td class="colLast">
<div class="block">A mutable builder for a <code>DoubleStream</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></td>
<td class="colLast">
<div class="block">A sequence of primitive int-valued elements supporting sequential and parallel
 aggregate operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/IntStream.Builder.html" title="interface in java.util.stream">IntStream.Builder</a></td>
<td class="colLast">
<div class="block">A mutable builder for an <code>IntStream</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></td>
<td class="colLast">
<div class="block">A sequence of primitive long-valued elements supporting sequential and parallel
 aggregate operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/LongStream.Builder.html" title="interface in java.util.stream">LongStream.Builder</a></td>
<td class="colLast">
<div class="block">A mutable builder for a <code>LongStream</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">A sequence of elements supporting sequential and parallel aggregate
 operations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/Stream.Builder.html" title="interface in java.util.stream">Stream.Builder</a>&lt;T&gt;</td>
<td class="colLast">
<div class="block">A mutable builder for a <code>Stream</code>.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/Collectors.html" title="class in java.util.stream">Collectors</a></td>
<td class="colLast">
<div class="block">Implementations of <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a> that implement various useful reduction
 operations, such as accumulating elements into collections, summarizing
 elements according to various criteria, etc.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/util/stream/StreamSupport.html" title="class in java.util.stream">StreamSupport</a></td>
<td class="colLast">
<div class="block">Low-level utility methods for creating and manipulating streams.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Enum Summary table, listing enums, and an explanation">
<caption><span>Enum Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Enum</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/util/stream/Collector.Characteristics.html" title="enum in java.util.stream">Collector.Characteristics</a></td>
<td class="colLast">
<div class="block">Characteristics indicating properties of a <code>Collector</code>, which can
 be used to optimize reduction implementations.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package java.util.stream Description">Package java.util.stream Description</h2>
<div class="block">Класове за поддържане на фунционален стил операции върху потоци от елементи, като
 map-reduce трансформации върху Колекции.  Например:

 <pre><code>
     int sum = widgets.stream()
                      .filter(b -&gt; b.getColor() == RED)
                      .mapToInt(b -&gt; b.getWeight())
                      .sum();
 </code></pre>

 <p>Тука използваме <code>джаджи (widgets)</code>, <code>Collection&lt;Widget&gt;</code>,
 като източник за поток, и след това изпълняваме filter-map-reduce върху потока
 за да получим сумата от теглата на червените джаджи.  (Сумирането е 
 пример за операция за намаляване(<a href="package-summary.html#Reduction">reduction operation</a>))

 <p>Основната абстракция, въведена в този пакет е поток<em>(stream)</em>. 
 Класовете <a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream"><code>Stream</code></a>, <a href="../../../java/util/stream/IntStream.html" title="interface in java.util.stream"><code>IntStream</code></a>,
 <a href="../../../java/util/stream/LongStream.html" title="interface in java.util.stream"><code>LongStream</code></a>, и <a href="../../../java/util/stream/DoubleStream.html" title="interface in java.util.stream"><code>DoubleStream</code></a>
 са потоци над обекти и примитивните типове <code>int</code>, <code>long</code> и
 <code>double</code>.  Потоците се различават от Колекциите по няколко неща:

 <ul>
     <li>Няма съхранение.  Потокът не е структура от данни, в която се съхраняват елементи;
     вместо това тя предава, елементи от източник като структура от данни, 
     масив, генераторна функция, или входно/изходен(I/O) канал, чрез конвейер(pipeline) 
     с изчислителни операции.</li>
     <li>Фунционален по природа.  Една операция в поток води до резултат,
     но не променя източника си.  Например, филтрирането на <code>Stream</code>
     получен от колекция генерира нов <code>Stream</code> без
     филтрираните елементи, вместо да премахва елементи от колекцията 
     източник.</li>
     <li>Мързелът търси своето. Много операции върху потоци, като филтриране, картографиране(mapping),
     или премахване на дублиранията, могат да бъдат изпълнени мързеливо, разкривайки възможности
     за оптимизация.  Например, "намери първият <code>String</code> с
     три последователни гласни букви" не е необходимо да разглежда всички входни низове.
     Операциите върху потоци са разделени на междинни(Intermediate) операции(<code>производствени потоци</code>)
     и крайни(terminal) операции (произвеждащи стойност или страничен ефект).
     Междинните опрации, винаги са мързеливи.</li>
     <li>Възможно неограничено.  Докато колекциите имат размери с граници, при 
     потоците не е нужно.  Short-circuiting операции като <code>limit(n)</code> или
     <code>findFirst()</code> позволяват изчисления върху безкрайни потоци 
     да завършат за определено време(но не безкрайно).</li>
     <li>Консумативен. Елементите на потока се посещават само веднъж 
     по време на живота на потока. Като <a href="../../../java/util/Iterator.html" title="interface in java.util"><code>Iterator</code></a>, 
     трябва да се генерира нов поток за да се посетят отново същите елементи от източника.
     </li>
 </ul>

 Потоците могат да се получат по няколко различни начина. Някои примери включват:
 <ul>
     <li>От <a href="../../../java/util/Collection.html" title="interface in java.util"><code>Collection</code></a> чрез методите <code>stream()</code> и
     <code>parallelStream()</code>;</li>
     <li>от масив чрез <a href="../../../java/util/Arrays.html#stream-T:A-"><code>Arrays.stream(Object[])</code></a>;</li>
     <li>От статични фабрични методи в Stream класовете, като
     <a href="../../../java/util/stream/Stream.html#of-T...-"><code>Stream.of(Object[])</code></a>,
     <a href="../../../java/util/stream/IntStream.html#range-int-int-"><code>IntStream.range(int, int)</code></a>
     или <a href="../../../java/util/stream/Stream.html#iterate-T-java.util.function.UnaryOperator-"><code>Stream.iterate(Object, UnaryOperator)</code></a>;</li>
     <li>Редовете на файл могат да бъдат получени от <a href="../../../java/io/BufferedReader.html#lines--"><code>BufferedReader.lines()</code></a>;</li>
     <li>Потоци от файлови пътища(paths) могат да бъдат получени от методи на класа <a href="../../../java/nio/file/Files.html" title="class in java.nio.file"><code>Files</code></a>;</li>
     <li>Потоци от случайни числа могат да бъдат получени от <a href="../../../java/util/Random.html#ints--"><code>Random.ints()</code></a>;</li>
     <li>Многобройни други поточно ориентирани методи(stream-bearing methods) в JDK, включително
     <a href="../../../java/util/BitSet.html#stream--"><code>BitSet.stream()</code></a>,
     <a href="../../../java/util/regex/Pattern.html#splitAsStream-java.lang.CharSequence-"><code>Pattern.splitAsStream(java.lang.CharSequence)</code></a>,
     и <a href="../../../java/util/jar/JarFile.html#stream--"><code>JarFile.stream()</code></a>.</li>
 </ul>

 <p>Допълнителни източници на поток могат да бъдат библиотеки от трети страни, използващи
 <a href="package-summary.html#StreamSources">тези техники</a>.

 <h2><a name="StreamOps">Операции върху потоци и конвейери(pipelines)</a></h2>

 <p>Поточните операции са разделени на <em>междинни</em> и
 <em>крайни</em>, и се комбинират за да образуват поточни конвейери (<em>stream
 pipelines</em>).  Поточния конвейер се състои от източник (като
 <code>Collection</code>, масив, генераторна функция, или I/O канал);
 последван от нула или повече междинни операции, като
 <code>Stream.filter</code> или <code>Stream.map</code>; и крайна операция като 
 <code>Stream.forEach</code> или <code>Stream.reduce</code>.

 <p>Междинните операции връщат нов поток.  Те винаги са
 <em>мързеливи</em>; изпълнението на междинна операция като
 <code>filter()</code> всъчщност не извършва никакво филтриране, а вместо това
 създава нов поток, към който при преминаването му, се копират елементи от
 първоначалния поток, съответстващи на даденото твърдение/условие(предикат).  Преминаването
 върху източника на конвейера не започва, докато не се изпълни
 крайната операция на конвейера.

 <p>Крайни операции, като <code>Stream.forEach</code> или
 <code>IntStream.sum</code>, могат да преминат през потока за да се получи резултат или
 страничен ефект(side-effect). След като се изпълни крайната операция, поточния конвейер 
 се счита за консумиран и вече не може да бъде използван; ако имате нужда да преминете през
 същият източник на данни, трябва да извършите "return", за да получите
 нов поток.  В почти всички случаи, крайните операции са <em>нетърпеливи</em>,
 завършвайки преминаването през източника на данни и обработката на конвейера
 преди "returning".  Само крайните операции <code>iterator()</code> и
 <code>spliterator()</code> не са; те са предоставени като "авариен люк"(escape hatch) 
 за да позволят своеволни, контролирани от клиента конвейерни траверси
 в случай че съществуващите операции не са достатъчни за задачата.

 <p> Обработката на потоци мързеливо, позволява значителна ефективност; в конвейер
 като примера за филтър-картографиране-сумиране по-горе, филтрирането, картографирането и
 сумирането могат да бъдат сляти в едно обхождане на данните, с минимално
 междинно състояние. Мързеливото използване позволява да се избегне изследването на всички данни,
 когато това не е необходимо; за операции като "намери първият стринг по-дълъг от 1000 символа",
 е необходимо да изследвате само достатъчно стрингове,
 за да намерите такъв който има желаните характеристики, без да изследвате
 всички стрингове налични в източника. ( Това поведение става още по-важно,
 когато входния поток е безкраен, а не просто голям.)

 <p>Междинните операции се разделят още на <em>безпристрастни(stateless)</em>
 и <em>състоятелни(stateful)</em> операции. Безпристрастни операции като <code>filter</code>
 и <code>map</code>, не запазват състояние на предишния елемент, когато обработват
 нов елемент -- всеки елемент може да бъде обработван 
 независимо от операциите върху други елементи.  Състоятелните операции като
 <code>distinct</code> и <code>sorted</code>, могат да включват състояние от предходни
 обходени елементи, когато се обработват нови елементи.

 <p>Състоятелните операции може да имат нужда от обработване на целия вход
 преди да се получи резултат.  Например не може да се получи резултат от
 сортирането на поткок, докато не се обходят всички елементи от потока. 
 В резултат на това, при паралелни изчисления някои конвейери,
 съдържащи състоятелни междинни операции, могат да изискат множество преминаване върху данните
 или може да се наложи да буферират значителни данни. 
 Потоците съдържащи изключително безпристрастни междинни операции
 могат да бъдат обработени в едно обхождане, независимо дали последователно или паралелно,
 с минимално буфериране на данни.

 <p>Освен това, някои операции се считат за <em>short-circuiting</em> операции.
 Една междинна операция е short-circuiting ако при наличие на
 безкраен вход, като резултат се получава поток с определен размер. Една крайна
 операция е short-circuiting ако, при наличие на безкраен вход, може да приключи
 в определено време.  Наличието на short-circuiting операция във конвейера
 е необходимо, но не достатъчно условие за обработка на безкраен поток
 за да се завърши нормално в определено време.

 <h3>Паралелизъм</h3>

 <p>Обработването на елементи с изричен <code>for-</code> цикъл е по същество серийно.
 Потоците улесняват паралелното изпълнение	чрез прецизиране на изчислението като конвейер
 от съвкупни операции, вместо императивни операции на всеки отделен елемент.
 Всички поточни операции могат да бъдат изпълнени серийно или паралелно.
 Поточните имплементации в JDK създават серийни потоци освен ако
 изрично не се изисква паралелизъм.  Например, <code>Collection</code> има методи
 <a href="../../../java/util/Collection.html#stream--"><code>Collection.stream()</code></a> и <a href="../../../java/util/Collection.html#parallelStream--"><code>Collection.parallelStream()</code></a>,
 които произвеждат съответно последователни и паралелни потоци; други
 потоко-създаващи методи като <a href="../../../java/util/stream/IntStream.html#range-int-int-"><code>IntStream.range(int, int)</code></a>
 генерират последователни потоци, но тези потоци могат да бъдат ефективно паралелизани чрез извикване на
 техния метод <a href="../../../java/util/stream/BaseStream.html#parallel--"><code>BaseStream.parallel()</code></a>.
 За да изпълним предходната заявка("сума от тегла на widgets") паралелно, ще направим следното:

 <pre><code>
     int sumOfWeights = widgets.</code><code><b>parallelStream()</b></code><code>
                               .filter(b -&gt; b.getColor() == RED)
                               .mapToInt(b -&gt; b.getWeight())
                               .sum();
 </code></pre>

 <p>Единствената разлика между сериината и паралелната версии на този пример е 
 създаването на първоначалния поток, като се използва "<code>parallelStream()</code>"
 вместо "<code>stream()</code>".  Когато се стартира крайна операция,
 конвейера за поток се изпълнява последователни или паралелно в зависимост от
 ориентацията на потока, върху който е извикана.  Дали потока ще се изпълнява серийно или  
 паралелно може да бъде определено с метода <code>isParallel()</code>, а ориентацията
 на потока може да бъде променена с операциите 
 <a href="../../../java/util/stream/BaseStream.html#sequential--"><code>BaseStream.sequential()</code></a> и
 <a href="../../../java/util/stream/BaseStream.html#parallel--"><code>BaseStream.parallel()</code></a>.  Когато е стартирана 
 крайна операция, поточния конвейер се изпълнява последователно или 
 паралелно в зависимост от видът на потока на който се извиква.

 <p>С изключение на операциите, определени като неубусловени като
 <code>findAny()</code>, независимо дали потокът се изпълнява последователно или паралелно,
 не трябва да променя резултата от изчислението.

 <p>Повечето поточни операции приемат параметри, описващи поведението 
 определено от потребителя, които често са ламбда изрази.  За да се запази правилно поведение,
 тези <em>поведенчески параметри</em> трябва да бъдат <em>non-interfering</em>, и 
 в повечето случаи трябва да бъдат <em>stateless</em>.  Такива параметри винаги са инстанции
 на <a href="../function/package-summary.html">функционален интерфейс</a> като 
 <a href="../../../java/util/function/Function.html" title="interface in java.util.function"><code>Function</code></a> и често са ламбда изрази 
 или референции на метода.

 <h3><a name="NonInterference">Non-interference</a></h3>

 Потоците ви позволяват да изпълнявате евентуално паралелни агрегатни операции
 върху различни източници на данни, включително дори  колекции, които не са безопасни за нишки<code>(non-thread-safe)</code>, като
 <code>ArrayList</code>. Това е възможно само ако можем да предотфратим
 <em>смущенията</em> в източника на данни по време на изпълнение на поточния
 конвейер. С изключение на авариини опрераци(escape-hatch) като <code>iterator()</code> и
 <code>spliterator()</code>, изпълнението започва когато е извикана крайна
 операция и завършва, когато крайната операция приключи. За повечето източници 
 на данни, предотфратяването на смущения означава, че източника на данни 
 <em>изобщо не се променя</em> по време на изпълнението на поточния конвейер.
 Забележително изключение са потоци, чиито източници са конкурентни колекции, 
 които са специално създаден, за да се справят с едновременната промяна.
 Конкурентни източници на потоци са тези, чийто <code>Spliterator</code> отчита 
 характеристиката <code>CONCURRENT</code>.

 <p>Accordingly, behavioral parameters in stream pipelines whose source might
 not be concurrent should never modify the stream's data source.
 A behavioral parameter is said to <em>interfere</em> with a non-concurrent
 data source if it modifies, or causes to be
 modified, the stream's data source.  The need for non-interference applies
 to all pipelines, not just parallel ones.  Unless the stream source is
 concurrent, modifying a stream's data source during execution of a stream
 pipeline can cause exceptions, incorrect answers, or nonconformant behavior.

 For well-behaved stream sources, the source can be modified before the
 terminal operation commences and those modifications will be reflected in
 the covered elements.  For example, consider the following code:

 <pre><code>
     List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));
     Stream&lt;String&gt; sl = l.stream();
     l.add("three");
     String s = sl.collect(joining(" "));
 </code></pre>

 First a list is created consisting of two strings: "one"; and "two". Then a
 stream is created from that list. Next the list is modified by adding a third
 string: "three". Finally the elements of the stream are collected and joined
 together. Since the list was modified before the terminal <code>collect</code>
 operation commenced the result will be a string of "one two three". All the
 streams returned from JDK collections, and most other JDK classes,
 are well-behaved in this manner; for streams generated by other libraries, see
 <a href="package-summary.html#StreamSources">Low-level stream
 construction</a> for requirements for building well-behaved streams.

 <h3><a name="Statelessness">Stateless behaviors</a></h3>

 Stream pipeline results may be nondeterministic or incorrect if the behavioral
 parameters to the stream operations are <em>stateful</em>.  A stateful lambda
 (or other object implementing the appropriate functional interface) is one
 whose result depends on any state which might change during the execution
 of the stream pipeline.  An example of a stateful lambda is the parameter
 to <code>map()</code> in:

 <pre><code>
     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
     stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...
 </code></pre>

 Here, if the mapping operation is performed in parallel, the results for the
 same input could vary from run to run, due to thread scheduling differences,
 whereas, with a stateless lambda expression the results would always be the
 same.

 <p>Note also that attempting to access mutable state from behavioral parameters
 presents you with a bad choice with respect to safety and performance; if
 you do not synchronize access to that state, you have a data race and
 therefore your code is broken, but if you do synchronize access to that
 state, you risk having contention undermine the parallelism you are seeking
 to benefit from.  The best approach is to avoid stateful behavioral
 parameters to stream operations entirely; there is usually a way to
 restructure the stream pipeline to avoid statefulness.

 <h3>Side-effects</h3>

 Side-effects in behavioral parameters to stream operations are, in general,
 discouraged, as they can often lead to unwitting violations of the
 statelessness requirement, as well as other thread-safety hazards.

 <p>If the behavioral parameters do have side-effects, unless explicitly
 stated, there are no guarantees as to the
 <a href="../concurrent/package-summary.html#MemoryVisibility"><i>visibility</i></a>
 of those side-effects to other threads, nor are there any guarantees that
 different operations on the "same" element within the same stream pipeline
 are executed in the same thread.  Further, the ordering of those effects
 may be surprising.  Even when a pipeline is constrained to produce a
 <em>result</em> that is consistent with the encounter order of the stream
 source (for example, <code>IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()</code>
 must produce <code>[0, 2, 4, 6, 8]</code>), no guarantees are made as to the order
 in which the mapper function is applied to individual elements, or in what
 thread any behavioral parameter is executed for a given element.

 <p>Many computations where one might be tempted to use side effects can be more
 safely and efficiently expressed without side-effects, such as using
 <a href="package-summary.html#Reduction">reduction</a> instead of mutable
 accumulators. However, side-effects such as using <code>println()</code> for debugging
 purposes are usually harmless.  A small number of stream operations, such as
 <code>forEach()</code> and <code>peek()</code>, can operate only via side-effects;
 these should be used with care.

 <p>As an example of how to transform a stream pipeline that inappropriately
 uses side-effects to one that does not, the following code searches a stream
 of strings for those matching a given regular expression, and puts the
 matches in a list.

 <pre><code>
     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
     stream.filter(s -&gt; pattern.matcher(s).matches())
           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
 </code></pre>

 This code unnecessarily uses side-effects.  If executed in parallel, the
 non-thread-safety of <code>ArrayList</code> would cause incorrect results, and
 adding needed synchronization would cause contention, undermining the
 benefit of parallelism.  Furthermore, using side-effects here is completely
 unnecessary; the <code>forEach()</code> can simply be replaced with a reduction
 operation that is safer, more efficient, and more amenable to
 parallelization:

 <pre><code>
     List&lt;String&gt;results =
         stream.filter(s -&gt; pattern.matcher(s).matches())
               .collect(Collectors.toList());  // No side-effects!
 </code></pre>

 <h3><a name="Ordering">Ordering</a></h3>

 <p>Streams may or may not have a defined <em>encounter order</em>.  Whether
 or not a stream has an encounter order depends on the source and the
 intermediate operations.  Certain stream sources (such as <code>List</code> or
 arrays) are intrinsically ordered, whereas others (such as <code>HashSet</code>)
 are not.  Some intermediate operations, such as <code>sorted()</code>, may impose
 an encounter order on an otherwise unordered stream, and others may render an
 ordered stream unordered, such as <a href="../../../java/util/stream/BaseStream.html#unordered--"><code>BaseStream.unordered()</code></a>.
 Further, some terminal operations may ignore encounter order, such as
 <code>forEach()</code>.

 <p>If a stream is ordered, most operations are constrained to operate on the
 elements in their encounter order; if the source of a stream is a <code>List</code>
 containing <code>[1, 2, 3]</code>, then the result of executing <code>map(x -&gt; x*2)</code>
 must be <code>[2, 4, 6]</code>.  However, if the source has no defined encounter
 order, then any permutation of the values <code>[2, 4, 6]</code> would be a valid
 result.

 <p>For sequential streams, the presence or absence of an encounter order does
 not affect performance, only determinism.  If a stream is ordered, repeated
 execution of identical stream pipelines on an identical source will produce
 an identical result; if it is not ordered, repeated execution might produce
 different results.

 <p>For parallel streams, relaxing the ordering constraint can sometimes enable
 more efficient execution.  Certain aggregate operations,
 such as filtering duplicates (<code>distinct()</code>) or grouped reductions
 (<code>Collectors.groupingBy()</code>) can be implemented more efficiently if ordering of elements
 is not relevant.  Similarly, operations that are intrinsically tied to encounter order,
 such as <code>limit()</code>, may require
 buffering to ensure proper ordering, undermining the benefit of parallelism.
 In cases where the stream has an encounter order, but the user does not
 particularly <em>care</em> about that encounter order, explicitly de-ordering
 the stream with <a href="../../../java/util/stream/BaseStream.html#unordered--"><code>unordered()</code></a> may
 improve parallel performance for some stateful or terminal operations.
 However, most stream pipelines, such as the "sum of weight of blocks" example
 above, still parallelize efficiently even under ordering constraints.

 <h2><a name="Reduction">Reduction operations</a></h2>

 A <em>reduction</em> operation (also called a <em>fold</em>) takes a sequence
 of input elements and combines them into a single summary result by repeated
 application of a combining operation, such as finding the sum or maximum of
 a set of numbers, or accumulating elements into a list.  The streams classes have
 multiple forms of general reduction operations, called
 <a href="../../../java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-"><code>reduce()</code></a>
 and <a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>collect()</code></a>,
 as well as multiple specialized reduction forms such as
 <a href="../../../java/util/stream/IntStream.html#sum--"><code>sum()</code></a>, <a href="../../../java/util/stream/IntStream.html#max--"><code>max()</code></a>,
 or <a href="../../../java/util/stream/IntStream.html#count--"><code>count()</code></a>.

 <p>Of course, such operations can be readily implemented as simple sequential
 loops, as in:
 <pre><code>
    int sum = 0;
    for (int x : numbers) {
       sum += x;
    }
 </code></pre>
 However, there are good reasons to prefer a reduce operation
 over a mutative accumulation such as the above.  Not only is a reduction
 "more abstract" -- it operates on the stream as a whole rather than individual
 elements -- but a properly constructed reduce operation is inherently
 parallelizable, so long as the function(s) used to process the elements
 are <a href="package-summary.html#Associativity">associative</a> and
 <a href="package-summary.html#NonInterfering">stateless</a>.
 For example, given a stream of numbers for which we want to find the sum, we
 can write:
 <pre><code>
    int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);
 </code></pre>
 or:
 <pre><code>
    int sum = numbers.stream().reduce(0, Integer::sum);
 </code></pre>

 <p>These reduction operations can run safely in parallel with almost no
 modification:
 <pre><code>
    int sum = numbers.parallelStream().reduce(0, Integer::sum);
 </code></pre>

 <p>Reduction parallellizes well because the implementation
 can operate on subsets of the data in parallel, and then combine the
 intermediate results to get the final correct answer.  (Even if the language
 had a "parallel for-each" construct, the mutative accumulation approach would
 still required the developer to provide
 thread-safe updates to the shared accumulating variable <code>sum</code>, and
 the required synchronization would then likely eliminate any performance gain from
 parallelism.)  Using <code>reduce()</code> instead removes all of the
 burden of parallelizing the reduction operation, and the library can provide
 an efficient parallel implementation with no additional synchronization
 required.

 <p>The "widgets" examples shown earlier shows how reduction combines with
 other operations to replace for loops with bulk operations.  If <code>widgets</code>
 is a collection of <code>Widget</code> objects, which have a <code>getWeight</code> method,
 we can find the heaviest widget with:
 <pre><code>
     OptionalInt heaviest = widgets.parallelStream()
                                   .mapToInt(Widget::getWeight)
                                   .max();
 </code></pre>

 <p>In its more general form, a <code>reduce</code> operation on elements of type
 <code>&lt;T&gt;</code> yielding a result of type <code>&lt;U&gt;</code> requires three parameters:
 <pre><code>
 &lt;U&gt; U reduce(U identity,
              BiFunction&lt;U, ? super T, U&gt; accumulator,
              BinaryOperator&lt;U&gt; combiner);
 </code></pre>
 Here, the <em>identity</em> element is both an initial seed value for the reduction
 and a default result if there are no input elements. The <em>accumulator</em>
 function takes a partial result and the next element, and produces a new
 partial result. The <em>combiner</em> function combines two partial results
 to produce a new partial result.  (The combiner is necessary in parallel
 reductions, where the input is partitioned, a partial accumulation computed
 for each partition, and then the partial results are combined to produce a
 final result.)

 <p>More formally, the <code>identity</code> value must be an <em>identity</em> for
 the combiner function. This means that for all <code>u</code>,
 <code>combiner.apply(identity, u)</code> is equal to <code>u</code>. Additionally, the
 <code>combiner</code> function must be <a href="package-summary.html#Associativity">associative</a> and
 must be compatible with the <code>accumulator</code> function: for all <code>u</code>
 and <code>t</code>, <code>combiner.apply(u, accumulator.apply(identity, t))</code> must
 be <code>equals()</code> to <code>accumulator.apply(u, t)</code>.

 <p>The three-argument form is a generalization of the two-argument form,
 incorporating a mapping step into the accumulation step.  We could
 re-cast the simple sum-of-weights example using the more general form as
 follows:
 <pre><code>
     int sumOfWeights = widgets.stream()
                               .reduce(0,
                                       (sum, b) -&gt; sum + b.getWeight())
                                       Integer::sum);
 </code></pre>
 though the explicit map-reduce form is more readable and therefore should
 usually be preferred. The generalized form is provided for cases where
 significant work can be optimized away by combining mapping and reducing
 into a single function.

 <h3><a name="MutableReduction">Mutable reduction</a></h3>

 A <em>mutable reduction operation</em> accumulates input elements into a
 mutable result container, such as a <code>Collection</code> or <code>StringBuilder</code>,
 as it processes the elements in the stream.

 <p>If we wanted to take a stream of strings and concatenate them into a
 single long string, we <em>could</em> achieve this with ordinary reduction:
 <pre><code>
     String concatenated = strings.reduce("", String::concat)
 </code></pre>

 <p>We would get the desired result, and it would even work in parallel.  However,
 we might not be happy about the performance!  Such an implementation would do
 a great deal of string copying, and the run time would be <em>O(n^2)</em> in
 the number of characters.  A more performant approach would be to accumulate
 the results into a <a href="../../../java/lang/StringBuilder.html" title="class in java.lang"><code>StringBuilder</code></a>, which is a mutable
 container for accumulating strings.  We can use the same technique to
 parallelize mutable reduction as we do with ordinary reduction.

 <p>The mutable reduction operation is called
 <a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>collect()</code></a>,
 as it collects together the desired results into a result container such
 as a <code>Collection</code>.
 A <code>collect</code> operation requires three functions:
 a supplier function to construct new instances of the result container, an
 accumulator function to incorporate an input element into a result
 container, and a combining function to merge the contents of one result
 container into another.  The form of this is very similar to the general
 form of ordinary reduction:
 <pre><code>
 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
               BiConsumer&lt;R, ? super T&gt; accumulator,
               BiConsumer&lt;R, R&gt; combiner);
 </code></pre>
 <p>As with <code>reduce()</code>, a benefit of expressing <code>collect</code> in this
 abstract way is that it is directly amenable to parallelization: we can
 accumulate partial results in parallel and then combine them, so long as the
 accumulation and combining functions satisfy the appropriate requirements.
 For example, to collect the String representations of the elements in a
 stream into an <code>ArrayList</code>, we could write the obvious sequential
 for-each form:
 <pre><code>
     ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
     for (T element : stream) {
         strings.add(element.toString());
     }
 </code></pre>
 Or we could use a parallelizable collect form:
 <pre><code>
     ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),
                                                (c, e) -&gt; c.add(e.toString()),
                                                (c1, c2) -&gt; c1.addAll(c2));
 </code></pre>
 or, pulling the mapping operation out of the accumulator function, we could
 express it more succinctly as:
 <pre><code>
     List&lt;String&gt; strings = stream.map(Object::toString)
                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
 </code></pre>
 Here, our supplier is just the <a href="../../../java/util/ArrayList.html#ArrayList--"><code>ArrayList constructor</code></a>, the accumulator adds the stringified element to an
 <code>ArrayList</code>, and the combiner simply uses <a href="../../../java/util/ArrayList.html#addAll-java.util.Collection-"><code>addAll</code></a>
 to copy the strings from one container into the other.

 <p>The three aspects of <code>collect</code> -- supplier, accumulator, and
 combiner -- are tightly coupled.  We can use the abstraction of a
 <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a> to capture all three aspects.  The
 above example for collecting strings into a <code>List</code> can be rewritten
 using a standard <code>Collector</code> as:
 <pre><code>
     List&lt;String&gt; strings = stream.map(Object::toString)
                                  .collect(Collectors.toList());
 </code></pre>

 <p>Packaging mutable reductions into a Collector has another advantage:
 composability.  The class <a href="../../../java/util/stream/Collectors.html" title="class in java.util.stream"><code>Collectors</code></a> contains a
 number of predefined factories for collectors, including combinators
 that transform one collector into another.  For example, suppose we have a
 collector that computes the sum of the salaries of a stream of
 employees, as follows:

 <pre><code>
     Collector&lt;Employee, ?, Integer&gt; summingSalaries
         = Collectors.summingInt(Employee::getSalary);
 </code></pre>

 (The <code>?</code> for the second type parameter merely indicates that we don't
 care about the intermediate representation used by this collector.)
 If we wanted to create a collector to tabulate the sum of salaries by
 department, we could reuse <code>summingSalaries</code> using
 <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-"><code>groupingBy</code></a>:

 <pre><code>
     Map&lt;Department, Integer&gt; salariesByDept
         = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,
                                                            summingSalaries));
 </code></pre>

 <p>As with the regular reduction operation, <code>collect()</code> operations can
 only be parallelized if appropriate conditions are met.  For any partially
 accumulated result, combining it with an empty result container must
 produce an equivalent result.  That is, for a partially accumulated result
 <code>p</code> that is the result of any series of accumulator and combiner
 invocations, <code>p</code> must be equivalent to
 <code>combiner.apply(p, supplier.get())</code>.

 <p>Further, however the computation is split, it must produce an equivalent
 result.  For any input elements <code>t1</code> and <code>t2</code>, the results
 <code>r1</code> and <code>r2</code> in the computation below must be equivalent:
 <pre><code>
     A a1 = supplier.get();
     accumulator.accept(a1, t1);
     accumulator.accept(a1, t2);
     R r1 = finisher.apply(a1);  // result without splitting

     A a2 = supplier.get();
     accumulator.accept(a2, t1);
     A a3 = supplier.get();
     accumulator.accept(a3, t2);
     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
 </code></pre>

 <p>Here, equivalence generally means according to <a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a>.
 but in some cases equivalence may be relaxed to account for differences in
 order.

 <h3><a name="ConcurrentReduction">Reduction, concurrency, and ordering</a></h3>

 With some complex reduction operations, for example a <code>collect()</code> that
 produces a <code>Map</code>, such as:
 <pre><code>
     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
         = txns.parallelStream()
               .collect(Collectors.groupingBy(Transaction::getBuyer));
 </code></pre>
 it may actually be counterproductive to perform the operation in parallel.
 This is because the combining step (merging one <code>Map</code> into another by
 key) can be expensive for some <code>Map</code> implementations.

 <p>Suppose, however, that the result container used in this reduction
 was a concurrently modifiable collection -- such as a
 <a href="../../../java/util/concurrent/ConcurrentHashMap.html" title="class in java.util.concurrent"><code>ConcurrentHashMap</code></a>. In that case, the parallel
 invocations of the accumulator could actually deposit their results
 concurrently into the same shared result container, eliminating the need for
 the combiner to merge distinct result containers. This potentially provides
 a boost to the parallel execution performance. We call this a
 <em>concurrent</em> reduction.

 <p>A <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a> that supports concurrent reduction is
 marked with the <a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a>
 characteristic.  However, a concurrent collection also has a downside.  If
 multiple threads are depositing results concurrently into a shared container,
 the order in which results are deposited is non-deterministic. Consequently,
 a concurrent reduction is only possible if ordering is not important for the
 stream being processed. The <a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>Stream.collect(Collector)</code></a>
 implementation will only perform a concurrent reduction if
 <ul>
 <li>The stream is parallel;</li>
 <li>The collector has the
 <a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a> characteristic,
 and;</li>
 <li>Either the stream is unordered, or the collector has the
 <a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>Collector.Characteristics.UNORDERED</code></a> characteristic.
 </ul>
 You can ensure the stream is unordered by using the
 <a href="../../../java/util/stream/BaseStream.html#unordered--"><code>BaseStream.unordered()</code></a> method.  For example:
 <pre><code>
     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
         = txns.parallelStream()
               .unordered()
               .collect(groupingByConcurrent(Transaction::getBuyer));
 </code></pre>
 (where <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>Collectors.groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;)</code></a> is the
 concurrent equivalent of <code>groupingBy</code>).

 <p>Note that if it is important that the elements for a given key appear in
 the order they appear in the source, then we cannot use a concurrent
 reduction, as ordering is one of the casualties of concurrent insertion.
 We would then be constrained to implement either a sequential reduction or
 a merge-based parallel reduction.

 <h3><a name="Associativity">Associativity</a></h3>

 An operator or function <code>op</code> is <em>associative</em> if the following
 holds:
 <pre><code>
     (a op b) op c == a op (b op c)
 </code></pre>
 The importance of this to parallel evaluation can be seen if we expand this
 to four terms:
 <pre><code>
     a op b op c op d == (a op b) op (c op d)
 </code></pre>
 So we can evaluate <code>(a op b)</code> in parallel with <code>(c op d)</code>, and
 then invoke <code>op</code> on the results.

 <p>Examples of associative operations include numeric addition, min, and
 max, and string concatenation.

 <h2><a name="StreamSources">Low-level stream construction</a></h2>

 So far, all the stream examples have used methods like
 <a href="../../../java/util/Collection.html#stream--"><code>Collection.stream()</code></a> or <a href="../../../java/util/Arrays.html#stream-T:A-"><code>Arrays.stream(Object[])</code></a>
 to obtain a stream.  How are those stream-bearing methods implemented?

 <p>The class <a href="../../../java/util/stream/StreamSupport.html" title="class in java.util.stream"><code>StreamSupport</code></a> has a number of
 low-level methods for creating a stream, all using some form of a
 <a href="../../../java/util/Spliterator.html" title="interface in java.util"><code>Spliterator</code></a>. A spliterator is the parallel analogue of an
 <a href="../../../java/util/Iterator.html" title="interface in java.util"><code>Iterator</code></a>; it describes a (possibly infinite) collection of
 elements, with support for sequentially advancing, bulk traversal, and
 splitting off some portion of the input into another spliterator which can
 be processed in parallel.  At the lowest level, all streams are driven by a
 spliterator.

 <p>There are a number of implementation choices in implementing a
 spliterator, nearly all of which are tradeoffs between simplicity of
 implementation and runtime performance of streams using that spliterator.
 The simplest, but least performant, way to create a spliterator is to
 create one from an iterator using
 <a href="../../../java/util/Spliterators.html#spliteratorUnknownSize-java.util.Iterator-int-"><code>Spliterators.spliteratorUnknownSize(java.util.Iterator, int)</code></a>.
 While such a spliterator will work, it will likely offer poor parallel
 performance, since we have lost sizing information (how big is the
 underlying data set), as well as being constrained to a simplistic
 splitting algorithm.

 <p>A higher-quality spliterator will provide balanced and known-size
 splits, accurate sizing information, and a number of other
 <a href="../../../java/util/Spliterator.html#characteristics--"><code>characteristics</code></a> of the
 spliterator or data that can be used by implementations to optimize
 execution.

 <p>Spliterators for mutable data sources have an additional challenge;
 timing of binding to the data, since the data could change between the time
 the spliterator is created and the time the stream pipeline is executed.
 Ideally, a spliterator for a stream would report a characteristic of

 <code>IMMUTABLE</code> or <code>CONCURRENT</code>; if not it should be
 <a href="../Spliterator.html#binding"><em>late-binding</em></a>. If a source
 cannot directly supply a recommended spliterator, it may indirectly supply
 a spliterator using a <code>Supplier</code>, and construct a stream via the
 <code>Supplier</code>-accepting versions of
 <a href="../../../java/util/stream/StreamSupport.html#stream-java.util.function.Supplier-int-boolean-"><code>stream()</code></a>.
 The spliterator is obtained from the supplier only after the terminal
 operation of the stream pipeline commences.

 <p>These requirements significantly reduce the scope of potential
 interference between mutations of the stream source and execution of stream
 pipelines. Streams based on spliterators with the desired characteristics,
 or those using the Supplier-based factory forms, are immune to
 modifications of the data source prior to commencement of the terminal
 operation (provided the behavioral parameters to the stream operations meet
 the required criteria for non-interference and statelessness).  See
 <a href="package-summary.html#NonInterference">Non-Interference</a>
 for more details.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.8</dd>
</dl>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><strong>Java&trade;&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../java/util/spi/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../java/util/zip/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?java/util/stream/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="https://docs.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> <a href="../../../../legal/cpyr.html">Copyright</a> &#x00a9; 1993, 2016, Oracle and/or its affiliates.  All rights reserved. Use is subject to <a href="http://download.oracle.com/otndocs/jcp/java_se-8-mrel-spec/license.html">license terms</a>. Also see the <a target="_blank" href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. </font></small></p>
</body>
</html>
